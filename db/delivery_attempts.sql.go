// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery_attempts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDeliverySummaryForEvent = `-- name: GetDeliverySummaryForEvent :many
SELECT
  subscriber_id,
  COUNT(*) FILTER (WHERE status = 'failed')::bigint AS failed_count,
  COUNT(*) FILTER (WHERE status = 'succeeded')::bigint AS succeeded_count
FROM delivery_attempts
WHERE event_id = $1
GROUP BY subscriber_id
`

type GetDeliverySummaryForEventRow struct {
	SubscriberID   pgtype.UUID
	FailedCount    int64
	SucceededCount int64
}

func (q *Queries) GetDeliverySummaryForEvent(ctx context.Context, eventID pgtype.UUID) ([]GetDeliverySummaryForEventRow, error) {
	rows, err := q.db.Query(ctx, getDeliverySummaryForEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeliverySummaryForEventRow
	for rows.Next() {
		var i GetDeliverySummaryForEventRow
		if err := rows.Scan(&i.SubscriberID, &i.FailedCount, &i.SucceededCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDeliveryAttempt = `-- name: InsertDeliveryAttempt :one
INSERT INTO delivery_attempts (id, event_id, subscriber_id, endpoint_url, attempted_at, request_headers, response_status_code, response_headers, response_body, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, event_id, subscriber_id, endpoint_url, attempted_at, request_headers, response_status_code, response_headers, response_body, status
`

type InsertDeliveryAttemptParams struct {
	ID                 pgtype.UUID
	EventID            pgtype.UUID
	SubscriberID       pgtype.UUID
	EndpointUrl        string
	AttemptedAt        pgtype.Timestamptz
	RequestHeaders     []byte
	ResponseStatusCode pgtype.Int4
	ResponseHeaders    []byte
	ResponseBody       string
	Status             string
}

func (q *Queries) InsertDeliveryAttempt(ctx context.Context, arg InsertDeliveryAttemptParams) (DeliveryAttempt, error) {
	row := q.db.QueryRow(ctx, insertDeliveryAttempt,
		arg.ID,
		arg.EventID,
		arg.SubscriberID,
		arg.EndpointUrl,
		arg.AttemptedAt,
		arg.RequestHeaders,
		arg.ResponseStatusCode,
		arg.ResponseHeaders,
		arg.ResponseBody,
		arg.Status,
	)
	var i DeliveryAttempt
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.SubscriberID,
		&i.EndpointUrl,
		&i.AttemptedAt,
		&i.RequestHeaders,
		&i.ResponseStatusCode,
		&i.ResponseHeaders,
		&i.ResponseBody,
		&i.Status,
	)
	return i, err
}

const listDeliveryAttemptsForEvent = `-- name: ListDeliveryAttemptsForEvent :many
SELECT id, event_id, subscriber_id, endpoint_url, attempted_at, request_headers, response_status_code, response_headers, response_body, status FROM delivery_attempts WHERE event_id = $1 ORDER BY attempted_at
`

func (q *Queries) ListDeliveryAttemptsForEvent(ctx context.Context, eventID pgtype.UUID) ([]DeliveryAttempt, error) {
	rows, err := q.db.Query(ctx, listDeliveryAttemptsForEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryAttempt
	for rows.Next() {
		var i DeliveryAttempt
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.SubscriberID,
			&i.EndpointUrl,
			&i.AttemptedAt,
			&i.RequestHeaders,
			&i.ResponseStatusCode,
			&i.ResponseHeaders,
			&i.ResponseBody,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryAttemptsForSubscriber = `-- name: ListDeliveryAttemptsForSubscriber :many
SELECT id, event_id, subscriber_id, endpoint_url, attempted_at, request_headers, response_status_code, response_headers, response_body, status FROM delivery_attempts WHERE subscriber_id = $1 ORDER BY attempted_at
`

func (q *Queries) ListDeliveryAttemptsForSubscriber(ctx context.Context, subscriberID pgtype.UUID) ([]DeliveryAttempt, error) {
	rows, err := q.db.Query(ctx, listDeliveryAttemptsForSubscriber, subscriberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryAttempt
	for rows.Next() {
		var i DeliveryAttempt
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.SubscriberID,
			&i.EndpointUrl,
			&i.AttemptedAt,
			&i.RequestHeaders,
			&i.ResponseStatusCode,
			&i.ResponseHeaders,
			&i.ResponseBody,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeliveryAttemptStatus = `-- name: UpdateDeliveryAttemptStatus :one
UPDATE delivery_attempts SET status = $1, response_status_code = $2, response_headers = $3, response_body = $4 WHERE id = $5 RETURNING id, event_id, subscriber_id, endpoint_url, attempted_at, request_headers, response_status_code, response_headers, response_body, status
`

type UpdateDeliveryAttemptStatusParams struct {
	Status             string
	ResponseStatusCode pgtype.Int4
	ResponseHeaders    []byte
	ResponseBody       string
	ID                 pgtype.UUID
}

func (q *Queries) UpdateDeliveryAttemptStatus(ctx context.Context, arg UpdateDeliveryAttemptStatusParams) (DeliveryAttempt, error) {
	row := q.db.QueryRow(ctx, updateDeliveryAttemptStatus,
		arg.Status,
		arg.ResponseStatusCode,
		arg.ResponseHeaders,
		arg.ResponseBody,
		arg.ID,
	)
	var i DeliveryAttempt
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.SubscriberID,
		&i.EndpointUrl,
		&i.AttemptedAt,
		&i.RequestHeaders,
		&i.ResponseStatusCode,
		&i.ResponseHeaders,
		&i.ResponseBody,
		&i.Status,
	)
	return i, err
}
